#pragma once

#include <SFML\Graphics.hpp>


#define PI_VALUE (3.142f)
typedef sf::Vector2f vec2;

//////////////////////////////////////////////////////////////////////////

float Length(vec2 v)
{
	return sqrt((v.x * v.x) + (v.y * v.y));
}

//////////////////////////////////////////////////////////////////////////

float LengthSq(vec2 v)
{
	return ((v.x * v.x) + (v.y * v.y));
}

//////////////////////////////////////////////////////////////////////////

vec2 Normalize(vec2 v)
{
	float length = Length(v);
	return vec2(v.x / length, v.y / length);
}

//////////////////////////////////////////////////////////////////////////

float Dot(vec2 v1, vec2 v2)
{
	return (v1.x * v2.x) + (v1.y * v2.y);
}

//////////////////////////////////////////////////////////////////////////

float RadiansToDegrees(float deg)
{
	return deg * (180.0f / PI_VALUE);
}

//////////////////////////////////////////////////////////////////////////

float DegreesToRadians(float deg)
{
	return deg * (PI_VALUE / 180.0f);
}

//////////////////////////////////////////////////////////////////////////

float ToAngle(vec2 v)
{
	return atan2f(v.y, v.x);
}

//////////////////////////////////////////////////////////////////////////

vec2 Rotate(vec2 v, float angleRadians)
{
	return vec2(
		v.x * cos(angleRadians) - v.y * sin(angleRadians),
		v.x * sin(angleRadians) + v.y * cos(angleRadians)
	);
}

//////////////////////////////////////////////////////////////////////////

vec2 Reflect(vec2 v, vec2 n)
{
	return v - 2 * Dot(v, n) * n;
}

//////////////////////////////////////////////////////////////////////////